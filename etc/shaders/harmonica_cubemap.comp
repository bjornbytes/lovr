#version 460
#extension GL_GOOGLE_include_directive : require

#include "lovr.glsl"

layout(local_size_x = 4, local_size_y = 4, local_size_z = 6) in;
#define THREADS 96

layout(set = 0, binding = 0, rgba8) uniform readonly imageCube cubemapU8;
layout(set = 0, binding = 1, std430) buffer writeonly Basis { vec3 basis[9]; };

shared vec3 coefficients[THREADS][9];
shared float totalAngle[THREADS];

void lovrmain() {
  uint id = LocalThreadIndex;
  uint face = LocalThreadID.z;

  totalAngle[id] = 0.;
  for (int i = 0; i < 9; i++) {
    coefficients[id][i] = vec3(0.);
  }

  int size = imageSize(cubemapU8).x;
  int tile = size / int(WorkgroupSize.x);
  ivec2 origin = ivec2(LocalThreadID.xy) * tile;
  float invSize = 2. / size;

  for (int y = 0; y < tile; y++) {
    for (int x = 0; x < tile; x++) {
      ivec2 xy = origin + ivec2(x, y);
      vec2 uv = (xy + .5) * invSize - 1.;

      vec3 dir;
      switch (face) {
        case 0: dir = vec3(-1., -uv.y, -uv.x); break;
        case 1: dir = vec3(+1., -uv.y, +uv.x); break;
        case 2: dir = vec3(-uv.x, +1., +uv.y); break;
        case 3: dir = vec3(-uv.x, -1., -uv.y); break;
        case 4: dir = vec3(-uv.x, -uv.y, +1.); break;
        case 5: dir = vec3(+uv.x, -uv.y, -1.); break;
      }

      float dir2 = dot(dir, dir);
      float len = sqrt(dir2);
      dir *= 1. / len;

      float solidAngle = 4. / (dir2 * len); // direction ^ (3/2)
      totalAngle[id] += solidAngle;

      vec3 texel = imageLoad(cubemapU8, ivec3(xy, face)).rgb;
      texel = pow(texel, vec3(2.2)); // >_<
      texel *= solidAngle;

      coefficients[id][0] += texel * .28209479177388;
      coefficients[id][1] += texel * .48860251190292 * dir.y;
      coefficients[id][2] += texel * .48860251190292 * dir.z;
      coefficients[id][3] += texel * .48860251190292 * dir.x;
      coefficients[id][4] += texel * 1.0925484305921 * dir.x * dir.y;
      coefficients[id][5] += texel * 1.0925484305921 * dir.y * dir.z;
      coefficients[id][6] += texel * .31539156525252 * (3. * dir.z * dir.z - 1.);
      coefficients[id][7] += texel * 1.0925484305921 * dir.x * dir.z;
      coefficients[id][8] += texel * .54627421529604 * (dir.x * dir.x - dir.y * dir.y);
    }
  }

  barrier();

  if (id == 0) {
    for (int t = 1; t < THREADS; t++) {
      totalAngle[0] += totalAngle[t];
      for (int i = 0; i < 9; i++) {
        coefficients[0][i] += coefficients[t][i];
      }
    }

    float scale = 4. * PI / totalAngle[0];

    for (int i = 0; i < 9; i++) {
      basis[i] = coefficients[0][i] * scale;
    }
  }
}
